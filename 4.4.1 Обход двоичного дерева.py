#Обход двоичного дерева
#Построить in-order, pre-order и post-order обходы данного двоичного дерева.
#Вход. Двоичное дерево; i-я строка задаёт числа keyi, lefti и righti, где keyi — ключ вершины i, lefti — индекс левого сына вершины i, а righti — индекс правого сына вершины i. Если у вершины i нет одного или обоих сыновей, соответствующее значение равно −1.
#Выход. Все его вершины в трёх разных порядках: in-order, pre-order и post-order. In-order обход соответствует следующей рекурсивной процедуре, получающей на вход корень v текущего поддерева: произвести рекурсивный вызов для v.left, напечатать v.key, произвести рекурсивный вызов для v.right. Pre-order обход: напечатать v.key, произвести рекурсивный вызов для v.left, произвести рекурсивный вызов для v.right. Post-order: произвести рекурсивный вызов для v.left, произвести рекурсивный вызов для v.right, напечатать v.key

def dfs(r, ii):    #первый параметр это индекс строки, второй - перебор внутри строки
    for i in ii:
        s = tree[r][i]
        yield from (dfs(s, ii) if s != -1 else ()) if i else (s,)    #возвращает генератор, рекурсивно идём по дереву, пока не будет -1 (база рекурсии), если i не равно 0, в ином случае возвращает кортеж с s 

tree = [tuple(map(int, input().split())) for _ in range(int(input()))]    #создаём список, состоящий из кортежей - каждой введённой строки
print(*dfs(0, (1, 0, 2)))    #печатаем каждый элемент вернувшегося генератора, цифры которые передаются - индексы, нужны для заданного выхода: in-order, pre-order и post-order
print(*dfs(0, (0, 1, 2)))
print(*dfs(0, (1, 2, 0)))
